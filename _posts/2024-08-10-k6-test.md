---
title: "[K6] K6 Test"
date: 2024-08-10
categories: [K6, Test]
tags: [K6, Test, JavaScript]
---

# K6 Test
## Lifecycle

- k6의 Lifecycle은 크게 네가지

```
// 1. 초기화
// 2. 전처리
export function setup() {
  //　로그인 토큰취득 등 API실행전에 필요한 처리 구현
}
// 3. API실행(시나리오 실행)
export default function (data) {
  // API를 실행할 시나리오를 구현
}
// 4. API 실행후 처리
export function teardown(data) {
  // API 실행후에 필요한 처리가 있다면 구현
}
```

## Test Code 작성 방법

```
import http from "k6/http" // http test

import { sleep } from "k6" // sleep 기능 사용 시 추가 (sleep(n) -> 지정한 n 기간 동한 VU 실행을 일시 중지)

export let options = {

	vus: 10,          // 가상의 유저 수

	duration: '1m'   // 테스트 진행 시간

};

const BASE_URL = '테스트 URL';

export default function () {

	let getUrl = BASE_URL

	http.get(getUrl);

	sleep(1);

}
```

```
import http from "k6/http";
import { sleep, check } from "k6";
import { Trend } from "k6/metrics";

const trends = {
  scenario1: new Trend("scenario1) Response time", true),
  scenario2: new Trend("scenario2) Response time", true),
};

const VUS = 1;
const DURATION = "10s";

export const options = {
  scenarios: {
    scenario1: {
      executor: "constant-vus",
      exec: "scenarioFunc",
      vus: VUS,
      duration: DURATION,
      env: {
        SCENARIO_ID: "1",
      },
    },
    scenario2: {
      executor: "constant-vus",
      exec: "scenarioFunc",
      vus: VUS,
      duration: DURATION,
      env: {
        SCENARIO_ID: "2",
      },
    },
  },
};

export function setup() {
  const url = ""; // token취득
  const params = {
    headers: {
      Authorization: "Bearer XXX",
    },
  };
  const res = http.get(url, params);
  const token = JSON.parse(res.body).account.token;

  return token;
}

export function scenarioFunc(token) {
  const scenarioUrl = ""; // 실행할 API
  const scenario = http.get(scenarioUrl, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  __ENV.SCENARIO_ID === "1"
    ? trends.scenario1.add(scenario.timings.duration)
    : trends.scenario2.add(scenario.timings.duration);

  check(scenario, {
    "scenario status is 200": (res) => res.status === 200,
  });

  sleep(1);
}
```

### Option 관련

```
export const options = {
  scenarios: {
    scenario1: {
      executor: "constant-vus",
      exec: "scenarioFunc",
      vus: VUS,
      duration: DURATION,
      env: {
        SCENARIO_ID: "1",
      },
    },
  },
};
```

- executor: k6의 실행 엔진을 나타냅니다.

여기에서 VU(Virtual user)나 스크립트 실행 패턴을 지정할 수 있습니다.
자세한 내용은 k6의 executors를 참조해주세요.

- exec: 실행하고자 하는 시나리오를 지정합니다.

- vus: Virtual Users API를 실행할 가상 유저입니다. 필요한 만큼의 병렬 실행수를 여기에 설정합니다.

- duration: VUS가 반복 시나리오를 실행하는 시간을 설정합니다.

- env: 공통으로 사용되는 변수를 설정할 수 있습니다.

### Trend 관련

```
const trends = {
  scenario1: new Trend("scenario1) Response time", true),
  scenario2: new Trend("scenario2) Response time", true),
};
```

- Trend는 실행 결과에 포함할 User 지정 Metric
- 이번에는 시나리오별 응답 시간을 통해 실행 결과에 포함시키기 위해 이용했습니다.
- Trend를 추가하면 아래와 같이 실행 결과에서 볼 수 있습니다.

```
scenario1) Response time.......: avg=1.29s    min=1.26s    med=1.29s max=1.35s    p(90)=1.34s    p(95)=1.34s
scenario2) Response time.......: avg=1.29s    min=1.25s    med=1.29s max=1.36s    p(90)=1.32s    p(95)=1.34s
```

### Setup 관련

```
export function setup() {
  const url = "";
  const params = {
    headers: {
      Authorization: "Bearer XXX",
    },
  };
  const res = http.get(url, params);
  const token = JSON.parse(res.body).account.token;

  return token;
}
```

- 여기에서는 토큰 취득 등 시나리오를 실행하기 전에 실행되어야할 처리를 설정하는 곳입니다.
- 로그인이 필요한 서비스를 가정하여 토큰을 취득했습니다.

### scenario 관련

```
export function scenarioFunc(token) {
  const scenarioUrl = "";
  const scenario = http.get(scenarioUrl, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  __ENV.SCENARIO_ID === "1"
    ? trends.scenario1.add(scenario.timings.duration)
    : trends.scenario2.add(scenario.timings.duration);

  check(scenario, {
    "scenario status is 200": (res) => res.status === 200,
  });

  sleep(1);
}
```

- 여기서 실행하고싶은 시나리오를 작성합니다.
- 이번에는 같은 API를 실행하는 시나리오를 2개 준비했기 때문에 그에따라 Trend를 실행 시나리오 아이디로 분리했습니다.

- check메서드는 값에 대해 true/false를 반환합니다.
- 여기에서는 API실행이 성공했는지 실패했는지 확인하고 결과에 기록합니다.
- 실패해도 중간에 멈추지 않고 실행하기 때문에 유연하게 대응할 수 있습니다.


> [k6 http module](https://k6.io/docs/using-k6/http-requests/#available-methods)
{: .prompt-info }

> [k6/http 테스트 방법](https://k6.io/docs/javascript-api/#k6-http)
{: .prompt-info }

> [k6 javascript-api](https://k6.io/docs/javascript-api/)
{: .prompt-info }

### Result

```
          /\      |‾‾| /‾‾/   /‾‾/
     /\  /  \     |  |/  /   /  /
    /  \/    \    |     (   /   ‾‾\
   /          \   |  |\  \ |  (‾)  |
  / __________ \  |__| \__\ \_____/ .io

  execution: local
     script: scripts.js
     output: -

  scenarios: (100.00%) 2 scenario, 200 max VUs, 40s max duration (incl. graceful stop):
           * scenario1: 1 looping VUS for 10s (exec: scenarioFunc, gracefulStop: 30s)
		   * scenario2: 1 looping VUS for 10s (exec: scenarioFunc, gracefulStop: 30s)


running (11.9s), 0/2 VUS, 16 complete and interrupted iterations
scenario1 ✓ [======================================] 1 VUS 10s
scenario2 ✓ [======================================] 1 VUS 10s

     ✓ scenario status is 200
	 
	 🁢 setup

     checks.........................: 100.00% ✓ 2893      ✗ 0
     data_received..................: 3.5 MB  58 kB/s
     data_sent......................: 416 kB  6.9 kB/s
     http_req_blocked...............: avg=49.33ms min=1µs      med=3µs   max=3.45s    p(90)=16µs    p(95)=377.18ms
     http_req_connecting............: avg=13.09ms min=0s       med=0s    max=199.77ms p(90)=0s      p(95)=186.36ms
     http_req_duration..............: avg=2.14s   min=190.5ms  med=1.32s max=5.79s    p(90)=5.39s   p(95)=5.57s
       { expected_response:true }...: avg=2.14s   min=190.5ms  med=1.32s max=5.79s    p(90)=5.39s   p(95)=5.57s
     http_req_failed................: 0.00%   ✓ 0         ✗ 2893
     http_req_receiving.............: avg=81.97µs min=19µs     med=61µs  max=2.43ms   p(90)=141.8µs p(95)=205.4µs
     http_req_sending...............: avg=22.37µs min=5µs      med=16µs  max=687µs    p(90)=38µs    p(95)=57µs
     http_req_tls_handshaking.......: avg=36.2ms  min=0s       med=0s    max=3.2s     p(90)=0s      p(95)=190.18ms
     http_req_waiting...............: avg=2.14s   min=190.38ms med=1.32s max=5.79s    p(90)=5.39s   p(95)=5.57s
     http_reqs......................: 2893    48.176768/s
     iteration_duration.............: avg=2.19s   min=190.7ms  med=1.39s max=6.05s    p(90)=5.4s    p(95)=5.58s
     iterations.....................: 2893    48.176768/s
	 scenario1) Response time.......: avg=1.29s   min=1.26s    med=1.29s max=1.36s    p(90)=1.32s   p(95)=1.34s
	 scenario2) Response time.......: avg=1.29s   min=1.25s    med=1.29s max=1.36s    p(90)=1.32s   p(95)=1.34s
     vus............................: 2       min=0       max=2
     vus_max........................: 2       min=2       max=2
```

- checks
	- 결과 : 100.00% ✓ 16 ✗ 0
	- 의미 : 요청이 성공한 비율(%)

- data_received
	- 결과 : 176 kB 15 kB / s
	- 의미 : 응답한 데이터 양 (Total, /s)

- data_sent
	- 결과 : 3 . 4 kB 282 B/s
	- 의미 : 요청한 데이터 양 (Total, /s)

- http_req_blocked
	- 결과 : avg=40.62ms min=0s med=1µs max=430.85ms p(90)=129.65ms p(95)=191.16ms
	- 의미 : TCP 접속 대기시간(avg, min, med, max, p(90), p(95)

- http_req_connecting
	- 결과 : avg=7.32ms min=0s med=0s max=42.24ms p(90)=41.03ms p(95)=41.69ms
	- 의미 : TCP 접속에 걸린시간(avg, min, med, max, p(90), p(95)

- http_req_duration
	- 결과 : avg=1.27s min=986.44ms med=1.28s max=1.36s p(90)=1.34s p(95)=1.35s
	- 의미 : http_req_sending + http_req_waiting + http_req_receiveing(avg, min, med, max, p(90), p(95)

- { expected_response:true }
	- 결과 : avg=1.27s min=986.44ms med=1.28s max=1.36s p(90)=1.34s p(95)=1.35s
	- 의미 : 정상응답만 http_req_duration(avg, min, med, max, p(90), p(95) 정상응답이 없을 경우 이 항목은 표시되지 않음

- http_req_failed
	- 결과 : 0.00% ✓ 0 ✗ 17
	- 의미 : 요청이 실패한 비율(%)

- http_req_receiving
	- 결과 : avg=194.76µs min=78µs med=95µs max=994µs p(90)=420.4µs p(95)=761.19µs
	- 의미 : 응답의 1바이트가 도달하고 나서 마지막 바이트를 수신할 때까지의 시간(avg, min, med, max, p(90), p(95)

- http_req_sending
	- 결과 : avg=139.76µs min=38µs med=48µs max=1.21ms p(90)=166.4µs p(95)=401.99µs
	- 의미 : 요청을 전송하는데 걸린시간(avg, min, med, max, p(90), p(95)

- http_req_tls_handshaking
	- 결과 : avg=29.7ms min=0s med=0s max=328.35ms p(90)=88.19ms p(95)=136.75ms
	- 의미 : TLS 세션의 핸드쉐이크에 걸린 시간(avg, min, med, max, p(90), p(95) http에서는 0

- http_req_waiting
	- 결과 : avg=1.27s min=985.15ms med=1.28s max=1.36s p(90)=1.34s p(95)=1.35s
	- 의미 : 요청이 전송 완료된 후 응답이 시작될 때까지의 시간(avg, min, med, max, p(90), p(95) TTFB(Time To First Byte)

- http_reqs
	- 결과 : 17 1.423196/s
	- 의미 : 총 리퀘스트수 (Total, /s)

- iteration_duration
	- 결과 : avg=1.31s min=1.25s med=1.29s max=1.49s p(90)=1.44s p(95)=1.48s
	- 의미 : 시나리오 1회 반복에 걸린 시간(avg, min, med, max, p(90), p(95)

- iterations
	- 결과 : 16 1.339479/s
	- 의미 : 시나리오 반복 횟수(Total, /s)

- vus
	- 결과 : 2 min=0 max=2
	- 의미 : Virtual UserS, 시나리오 실행시 유저수(병렬)

- vus_max
	- 결과 : 2 min=0 max=2
	- 의미 : 최대 Virtual UserS, 시나리오의 최대 실행유저수(병렬)

## [Test 측정 항목](https://k6.io/docs/using-k6/metrics/reference/#standard-built-in-metrics)

| Metric Name | Type | Description |
|:-|:-|:-|
| vus | Gauge | 현재 활성화 된 사용자 유저 |
| vus_max | Gauge | 가능한 최대 가상 사용자 수(로드 레벨을 확장할 때 성능에 영향을 미치지 않도록 VU 리소스가 미리 할당됨) |
| iterations | Counter | 테스트에서 Vu 가 JS 스크립트를 실행한 총 횟수 |
| iteration_duration | Trend | default/main function 의 전체 반복을 한 번 완료하는데 소요된 시간 |
| dropped_iterations | Counter | k6 v0.27.0 에 도입된 VU lack 또는 lack of time 으로 인해 시작할 수 없는 반복 회수 |
| data_received | Counter | 데이터를 전달받은 양 |
| data_sent | Counter | 데이터를 전달한 양 |
| checks | Rate | 성공적으로 체크된 Rate |

## [Http 측정 항목](https://k6.io/docs/using-k6/metrics/reference/#http)

| Metric Name | Type | Description |
|:-|:-|:-|
| http_reqs | Counter | 총 얼마나 많은 HTTP requests 를 k6 에서 생성했는지 횟수 |
| http_req_blocked | Trend | 요청을 시작하기 전에 차단된 시간(TCP connection slot 을 기다리는) 단위: float |
| http_req_connecting | Trend | 원격 호스트에 대한 TCP 연결을 설정하는데 소요된 시간. 단위: float |
| http_req_tls_handshaking | Trend | 원격 호스트와의 핸드셰이킹 TLS 세션에 소요된 시간 |
| http_req_sending | Trend | 원격 호스트에 데이터를 보내는데 소요된 시간. 단위: float |
| http_req_waiting | Trend | 원격 호스트로부터의 응답을 대기하는 데 소요된 시간 (a.k.a. “time to first byte”, or “TTFB”). 단위: float |
| http_req_receiving | Trend | 원격 호스트로부터 응답 데이터를 수신하는 데 소요된 시간. 단위: float |
| http_req_duration | Trend | 요청의 총 시간. It's equal to http_req_sending + http_req_waiting + http_req_receiving (즉, 초기 DNS 조회/연결 시간 없이 원격 서버가 요청을 처리하고 응답하는 데 소요된 시간s). 단위: float |
| http_req_failed | Rate | [setResponseCallback](https://k6.io/docs/javascript-api/k6-http/setresponsecallback/) 에 따른 요칭 실패 비율. |


> [Swagger API](https://k6.io/blog/load-testing-your-api-with-swagger-openapi-and-k6/)
{: .prompt-info }

> [Postman](https://grafana.com/blog/2020/04/19/load-testing-your-api-with-postman/)
{: .prompt-info }

> [k6-learn](https://github.com/grafana/k6-learn)
{: .prompt-info }