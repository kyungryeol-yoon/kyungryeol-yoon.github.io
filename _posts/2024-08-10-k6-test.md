---
title: "[K6] K6 Test"
date: 2024-08-10
categories: [K6, Test]
tags: [K6, Test, JavaScript]
---

# K6 Test
## Lifecycle

- k6의 Lifecycle은 크게 네가지

```
// 1. 초기화
// 2. 전처리
export function setup() {
  //　로그인 토큰취득 등 API실행전에 필요한 처리 구현
}
// 3. API실행(시나리오 실행)
export default function (data) {
  // API를 실행할 시나리오를 구현
}
// 4. API 실행후 처리
export function teardown(data) {
  // API 실행후에 필요한 처리가 있다면 구현
}
```

## Test Code 작성 방법

```
import http from "k6/http" // http test

import { sleep } from "k6" // sleep 기능 사용 시 추가 (sleep(n) -> 지정한 n 기간 동한 VU 실행을 일시 중지)

export let options = {

	vus: 10,          // 가상의 유저 수

	duration: '1m'   // 테스트 진행 시간

};

const BASE_URL = '테스트 URL';

export default function () {

	let getUrl = BASE_URL

	http.get(getUrl);

	sleep(1);

}
```

```
import http from "k6/http";
import { sleep, check } from "k6";
import { Trend } from "k6/metrics";

const trends = {
  scenario1: new Trend("scenario1) Response time", true),
  scenario2: new Trend("scenario2) Response time", true),
};

const VUS = 1;
const DURATION = "10s";

export const options = {
  scenarios: {
    scenario1: {
      executor: "constant-vus",
      exec: "scenarioFunc",
      vus: VUS,
      duration: DURATION,
      env: {
        SCENARIO_ID: "1",
      },
    },
    scenario2: {
      executor: "constant-vus",
      exec: "scenarioFunc",
      vus: VUS,
      duration: DURATION,
      env: {
        SCENARIO_ID: "2",
      },
    },
  },
};

export function setup() {
  const url = ""; // token취득
  const params = {
    headers: {
      Authorization: "Bearer XXX",
    },
  };
  const res = http.get(url, params);
  const token = JSON.parse(res.body).account.token;

  return token;
}

export function scenarioFunc(token) {
  const scenarioUrl = ""; // 실행할 API
  const scenario = http.get(scenarioUrl, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  __ENV.SCENARIO_ID === "1"
    ? trends.scenario1.add(scenario.timings.duration)
    : trends.scenario2.add(scenario.timings.duration);

  check(scenario, {
    "scenario status is 200": (res) => res.status === 200,
  });

  sleep(1);
}
```

### Option 관련

```
export const options = {
  scenarios: {
    scenario1: {
      executor: "constant-vus",
      exec: "scenarioFunc",
      vus: VUS,
      duration: DURATION,
      env: {
        SCENARIO_ID: "1",
      },
    },
  },
};
```

- executor: k6의 실행 엔진을 나타냅니다.

여기에서 VU(Virtual user)나 스크립트 실행 패턴을 지정할 수 있습니다.
자세한 내용은 k6의 executors를 참조해주세요.

- exec: 실행하고자 하는 시나리오를 지정합니다.

- vus: Virtual Users API를 실행할 가상 유저입니다. 필요한 만큼의 병렬 실행수를 여기에 설정합니다.

- duration: VUS가 반복 시나리오를 실행하는 시간을 설정합니다.

- env: 공통으로 사용되는 변수를 설정할 수 있습니다.

### Trend 관련

```
const trends = {
  scenario1: new Trend("scenario1) Response time", true),
  scenario2: new Trend("scenario2) Response time", true),
};
```

- Trend는 실행 결과에 포함할 User 지정 Metric
- 이번에는 시나리오별 응답 시간을 통해 실행 결과에 포함시키기 위해 이용했습니다.
- Trend를 추가하면 아래와 같이 실행 결과에서 볼 수 있습니다.

```
scenario1) Response time.......: avg=1.29s    min=1.26s    med=1.29s max=1.35s    p(90)=1.34s    p(95)=1.34s
scenario2) Response time.......: avg=1.29s    min=1.25s    med=1.29s max=1.36s    p(90)=1.32s    p(95)=1.34s
```

### Setup 관련

```
export function setup() {
  const url = "";
  const params = {
    headers: {
      Authorization: "Bearer XXX",
    },
  };
  const res = http.get(url, params);
  const token = JSON.parse(res.body).account.token;

  return token;
}
```

- 여기에서는 토큰 취득 등 시나리오를 실행하기 전에 실행되어야할 처리를 설정하는 곳입니다.
- 로그인이 필요한 서비스를 가정하여 토큰을 취득했습니다.

### scenario 관련

```
export function scenarioFunc(token) {
  const scenarioUrl = "";
  const scenario = http.get(scenarioUrl, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  __ENV.SCENARIO_ID === "1"
    ? trends.scenario1.add(scenario.timings.duration)
    : trends.scenario2.add(scenario.timings.duration);

  check(scenario, {
    "scenario status is 200": (res) => res.status === 200,
  });

  sleep(1);
}
```

- 여기서 실행하고싶은 시나리오를 작성합니다.
- 이번에는 같은 API를 실행하는 시나리오를 2개 준비했기 때문에 그에따라 Trend를 실행 시나리오 아이디로 분리했습니다.

- check메서드는 값에 대해 true/false를 반환합니다.
- 여기에서는 API실행이 성공했는지 실패했는지 확인하고 결과에 기록합니다.
- 실패해도 중간에 멈추지 않고 실행하기 때문에 유연하게 대응할 수 있습니다.


> [k6 http module](https://k6.io/docs/using-k6/http-requests/#available-methods)
{: .prompt-info }

> [k6/http 테스트 방법](https://k6.io/docs/javascript-api/#k6-http)
{: .prompt-info }

> [k6 javascript-api](https://k6.io/docs/javascript-api/)
{: .prompt-info }

### Result

- checks
	- 결과 : 100.00% ✓ 16 ✗ 0
	- 의미 : 요청이 성공한 비율(%)

- data_received
	- 결과: 176 kB 15 kB / s
	- 의미:응답한 데이터 양 (Total, /s)

- data_sent
	- 결과
	3 . 4 kB 282 B/s
	- 의미
	요청한 데이터 양 (Total, /s)

- http_req_blocked
	- 결과
	avg=40.62ms min=0s med=1µs max=430.85ms p(90)=129.65ms p(95)=191.16ms
	- 의미
	TCP 접속 대기시간(avg, min, med, max, p(90), p(95)
- http_req_connecting
	- 결과
	avg=7.32ms min=0s med=0s max=42.24ms p(90)=41.03ms p(95)=41.69ms
	- 의미
	TCP 접속에 걸린시간(avg, min, med, max, p(90), p(95)
- http_req_duration
	- 결과
	avg=1.27s min=986.44ms med=1.28s max=1.36s p(90)=1.34s p(95)=1.35s
	- 의미
	http_req_sending + http_req_waiting + http_req_receiveing(avg, min, med, max, p(90), p(95)

{ expected_response:true }

	- 결과
	avg=1.27s min=986.44ms med=1.28s max=1.36s p(90)=1.34s p(95)=1.35s
	- 의미
	정상응답만 http_req_duration(avg, min, med, max, p(90), p(95) 정상응답이 없을 경우 이 항목은 표시되지 않음
- http_req_failed
	- 결과
	0.00% ✓ 0 ✗ 17
	- 의미
	요청이 실패한 비율(%)
- http_req_receiving
결과
avg=194.76µs min=78µs med=95µs max=994µs p(90)=420.4µs p(95)=761.19µs
의미
응답의 1바이트가 도달하고 나서 마지막 바이트를 수신할 때까지의 시간(avg, min, med, max, p(90), p(95)
http_req_sending
결과
avg=139.76µs min=38µs med=48µs max=1.21ms p(90)=166.4µs p(95)=401.99µs
의미
요청을 전송하는데 걸린시간(avg, min, med, max, p(90), p(95)
http_req_tls_handshaking
결과
avg=29.7ms min=0s med=0s max=328.35ms p(90)=88.19ms p(95)=136.75ms
의미
TLS 세션의 핸드쉐이크에 걸린 시간(avg, min, med, max, p(90), p(95) http에서는 0
http_req_waiting
결과
avg=1.27s min=985.15ms med=1.28s max=1.36s p(90)=1.34s p(95)=1.35s
의미
요청이 전송 완료된 후 응답이 시작될 때까지의 시간(avg, min, med, max, p(90), p(95) TTFB(Time To First Byte)
http_reqs
결과
17 1.423196/s
의미
총 리퀘스트수 (Total, /s)
iteration_duration
결과
avg=1.31s min=1.25s med=1.29s max=1.49s p(90)=1.44s p(95)=1.48s
의미
시나리오 1회 반복에 걸린 시간(avg, min, med, max, p(90), p(95)
iterations
결과
16 1.339479/s
의미
시나리오 반복 횟수(Total, /s)
vus
결과
2 min=0 max=2
의미
Virtual UserS, 시나리오 실행시 유저수(병렬)
vus_max
결과
2 min=0 max=2
의미
최대 Virtual UserS, 시나리오의 최대 실행유저수(병렬)

## [Test 측정 항목](https://k6.io/docs/using-k6/metrics/reference/#standard-built-in-metrics)

| Metric Name | Type | Description |
|:-|:-|:-|
| vus | Gauge | 현재 활성화 된 사용자 유저 |
| vus_max | Gauge | 가능한 최대 가상 사용자 수(로드 레벨을 확장할 때 성능에 영향을 미치지 않도록 VU 리소스가 미리 할당됨) |
| iterations | Counter | 테스트에서 Vu 가 JS 스크립트를 실행한 총 횟수 |
| iteration_duration | Trend | default/main function 의 전체 반복을 한 번 완료하는데 소요된 시간 |
| dropped_iterations | Counter | k6 v0.27.0 에 도입된 VU lack 또는 lack of time 으로 인해 시작할 수 없는 반복 회수 |
| data_received | Counter | 데이터를 전달받은 양 |
| data_sent | Counter | 데이터를 전달한 양 |
| checks | Rate | 성공적으로 체크된 Rate |

## [Http 측정 항목](https://k6.io/docs/using-k6/metrics/reference/#http)

| Metric Name | Type | Description |
|:-|:-|:-|
| http_reqs | Counter | 총 얼마나 많은 HTTP requests 를 k6 에서 생성했는지 횟수 |
| http_req_blocked | Trend | 요청을 시작하기 전에 차단된 시간(TCP connection slot 을 기다리는) 단위: float |
| http_req_connecting | Trend | 원격 호스트에 대한 TCP 연결을 설정하는데 소요된 시간. 단위: float |
| http_req_tls_handshaking | Trend | 원격 호스트와의 핸드셰이킹 TLS 세션에 소요된 시간 |
| http_req_sending | Trend | 원격 호스트에 데이터를 보내는데 소요된 시간. 단위: float |
| http_req_waiting | Trend | 원격 호스트로부터의 응답을 대기하는 데 소요된 시간 (a.k.a. “time to first byte”, or “TTFB”). 단위: float |
| http_req_receiving | Trend | 원격 호스트로부터 응답 데이터를 수신하는 데 소요된 시간. 단위: float |
| http_req_duration | Trend | 요청의 총 시간. It's equal to http_req_sending + http_req_waiting + http_req_receiving (즉, 초기 DNS 조회/연결 시간 없이 원격 서버가 요청을 처리하고 응답하는 데 소요된 시간s). 단위: float |
| http_req_failed | Rate | [setResponseCallback](https://k6.io/docs/javascript-api/k6-http/setresponsecallback/) 에 따른 요칭 실패 비율. |


> [Swagger API](https://k6.io/blog/load-testing-your-api-with-swagger-openapi-and-k6/)
{: .prompt-info }

> [Postman](https://grafana.com/blog/2020/04/19/load-testing-your-api-with-postman/)
{: .prompt-info }